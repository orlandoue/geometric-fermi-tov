# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jSJGJo1f6oDXPeIFGvvWGy8bjb_pPWhd
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad, solve_ivp
from scipy.interpolate import interp1d

# ==========================================
# SCRIPT FOR FIGURE 2: SENSITIVITY & CAUSALITY
# ==========================================

# --- 1. CONSTANTS & UNITS ---
HBAR_C = 197.327          # MeV fm
MN = 939.565              # Neutron Mass (MeV)
HC_FACTOR = 1.0/(HBAR_C**3)
MEV_FM3_TO_KM2 = 1.3234e-6 # Geometric Units Conversion
KM_TO_MSUN = 1.0/1.4766    # Mass Conversion

# --- 2. PHYSICS KERNEL ---
def phi_suppression(k, alpha, k_cut):
    return 1.0 / (1.0 + alpha * (k/k_cut)**2)

def integrand_energy(k, alpha, k_cut):
    E = np.sqrt(k**2 + MN**2)
    return (1.0/np.pi**2) * phi_suppression(k, alpha, k_cut) * k**2 * E

def integrand_pressure(k, alpha, k_cut):
    E = np.sqrt(k**2 + MN**2)
    return (1.0/(3*np.pi**2)) * phi_suppression(k, alpha, k_cut) * (k**4)/E

# --- 3. SOLVER UTILS ---
def get_eos(alpha, k_cut=250.0):
    """Generates EoS table for a given Alpha"""
    k_vals = np.linspace(10, 3000, 200)
    rho, p = [], []
    for kf in k_vals:
        e_raw, _ = quad(integrand_energy, 0, kf, args=(alpha, k_cut))
        p_raw, _ = quad(integrand_pressure, 0, kf, args=(alpha, k_cut))
        rho.append(e_raw * HC_FACTOR * MEV_FM3_TO_KM2)
        p.append(p_raw * HC_FACTOR * MEV_FM3_TO_KM2)
    return np.array(rho), np.array(p)

def solve_star_max_mass(eos_rho, eos_p):
    """Finds the maximum mass for a given EoS"""
    p_to_rho = interp1d(eos_p, eos_rho, kind='cubic', fill_value="extrapolate")

    def tov(r, y):
        P, m = y
        if P <= 0: return [0, 0]
        rho = p_to_rho(P)
        denom = r*(r-2*m) if r > 1e-4 else 1.0
        dP = - (rho+P)*(m + 4*np.pi*r**3*P) / denom
        dm = 4*np.pi*r**2*rho
        return [dP, dm]

    def surface(r, y): return y[0]
    surface.terminal = True
    surface.direction = -1

    # Scan central pressures to find the peak
    central_ps = np.logspace(np.log10(eos_p[20]), np.log10(eos_p[-10]), 30)
    max_m = 0.0

    for Pc in central_ps:
        r_min, rho_c = 1e-4, p_to_rho(Pc)
        m_min = 4/3*np.pi*r_min**3 * rho_c
        sol = solve_ivp(tov, [r_min, 30], [Pc, m_min], events=surface, rtol=1e-4)
        if sol.status == 1:
            M = sol.y[1][-1] * KM_TO_MSUN
            if M > max_m: max_m = M
    return max_m

def get_vs_profile(alpha=4.1, k_cut=250.0):
    """Calculates speed of sound profile for the max mass star"""
    # High resolution EoS for derivatives
    eos_rho, eos_p = get_eos(alpha, k_cut)

    # Calculate vs^2 = dP/drho
    dP = np.diff(eos_p)
    drho = np.diff(eos_rho)
    vs_sq = dP/drho
    vs = np.sqrt(vs_sq)
    rho_mid = (eos_rho[1:] + eos_rho[:-1])/2

    # Interpolators
    p_to_rho = interp1d(eos_p, eos_rho, kind='cubic', fill_value="extrapolate")
    rho_to_vs = interp1d(rho_mid, vs, kind='linear', fill_value="extrapolate")

    # Solve specifically for the massive star
    # Note: For alpha=4.1, the max mass is at high pressure. We pick a representative Pc.
    Pc_target = eos_p[-25]

    def tov_profile(r, y):
        P, m = y
        if P <= 0: return [0, 0]
        rho = p_to_rho(P)
        denom = r*(r-2*m) if r > 1e-4 else 1.0
        dP = - (rho+P)*(m + 4*np.pi*r**3*P) / denom
        dm = 4*np.pi*r**2*rho
        return [dP, dm]

    def surface(r, y): return y[0]
    surface.terminal = True
    surface.direction = -1

    r_min, rho_c = 1e-4, p_to_rho(Pc_target)
    m_min = 4/3*np.pi*r_min**3 * rho_c
    sol = solve_ivp(tov_profile, [r_min, 30], [Pc_target, m_min], events=surface, rtol=1e-5)

    # Map r -> P -> rho -> vs
    r_vals = sol.t
    p_vals = sol.y[0]
    vs_vals = []
    for p_val in p_vals:
        if p_val <= 0: vs_vals.append(0)
        else:
            rho_val = p_to_rho(p_val)
            # Clip rho to stay within interpolation range
            if rho_val > rho_mid[-1]: rho_val = rho_mid[-1]
            if rho_val < rho_mid[0]: rho_val = rho_mid[0]
            vs_vals.append(rho_to_vs(rho_val))

    return r_vals, np.array(vs_vals)

# --- 4. PLOTTING EXECUTION ---
print("Generating Figure 2: Sensitivity & Causality...")

# A. Sensitivity Scan
alphas = [2.0, 3.0, 4.1, 5.0, 6.0]
masses = []
for a in alphas:
    print(f"  > Calculating Max Mass for Alpha = {a}...")
    rho, p = get_eos(a)
    m = solve_star_max_mass(rho, p)
    masses.append(m)

# B. Causality Profile (for Alpha=4.1)
print("  > Calculating Speed of Sound Profile...")
r_prof, vs_prof = get_vs_profile(4.1)

# Plot
plt.style.use('default')
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4.5))

# Panel 1: Sensitivity
ax1.plot(alphas, masses, '-o', color='#1f77b4', linewidth=2)
ax1.axhline(2.35, color='#FBC02D', linestyle='--', label='Target: PSR J0952-0607')
ax1.plot(4.1, 2.35, 'o', color='#D32F2F', label=r'Calibrated $\alpha=4.1$', zorder=5)
ax1.set_xlabel(r'Coupling Parameter $\alpha$', fontsize=11)
ax1.set_ylabel(r'Maximum Mass ($M_{\odot}$)', fontsize=11)
ax1.set_title('Sensitivity Analysis', fontsize=12)
ax1.grid(True, alpha=0.3)
ax1.legend()

# Panel 2: Causality
ax2.plot(r_prof, vs_prof, color='#D32F2F', linewidth=2, label=r'$v_s(r)$ for Max Mass')
ax2.axhline(1.0, color='black', linestyle='--', label='Speed of Light ($c$)')
ax2.axhline(0.577, color='gray', linestyle=':', label=r'$c/\sqrt{3}$ (Limit)')
ax2.set_xlabel('Radius (km)', fontsize=11)
ax2.set_ylabel(r'Speed of Sound ($v_s/c$)', fontsize=11)
ax2.set_title('Causality Check', fontsize=12)
ax2.set_ylim(0, 1.1)
ax2.grid(True, alpha=0.3)
ax2.legend(loc='lower right')

plt.tight_layout()
plt.savefig('figure2_analysis.pdf', dpi=300)
print("SUCCESS: 'figure2_analysis.pdf' saved.")